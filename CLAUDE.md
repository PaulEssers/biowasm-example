# CLAUDE.md — wasm-example

## What this project is

A sandbox for converting bioinformatics CLI tools to WebAssembly and running them in the browser. The current tool (`gc_calculator`) is a Rust toy example; the eventual real tools will be C/C++ programs compiled with Emscripten.

## Key architectural decision: wasm-pack vs aioli

- **Rust tools** use `wasm-pack` (`wasm-bindgen`, target `wasm32-unknown-unknown`). They export typed JS functions via ES modules. The browser calls them directly.
- **C/C++ tools** (future) will use [aioli from biowasm](https://biowasm.com/documentation/). Aioli wraps Emscripten-compiled CLI binaries and provides a shared virtual filesystem. It is *not* compatible with wasm-pack output.

Do not try to load a wasm-pack tool through aioli, or vice versa.

## Project structure

```
tools/                  # one directory per tool, each self-contained
  gc_calculator/        #   Rust / wasm-pack tool
    Cargo.toml
    src/lib.rs          #   source + unit tests
    pkg/                #   wasm-pack output (gitignored)
  kalign/               #   C tool via aioli (binary fetched from biowasm CDN)
    download.sh         #   downloads pre-built .wasm + .js into pkg/
    pkg/                #   downloaded binary (gitignored)
web/                    # single frontend; one .ts file per tool
  index.html            #   shell only: sidebar nav + tool-area container
  aioli.d.ts            #   ambient type declarations for the Aioli CDN global
  main.ts               #   tool registry, sidebar logic, lazy init/swap
  gc_calculator.ts      #   wasm-pack tool module  →  gc_calculator.js
  kalign.ts             #   aioli tool module      →  kalign.js
  favicon.svg           #   hand-drawn DNA helix icon
  *.js                  #   (gitignored, generated by tsc)
test-data/              # shared test fixtures
tsconfig.json           # TypeScript config (ES2020 modules, bundler resolution)
package.json            # npm dev server + typescript
Makefile                # make test-gc-calculator | make run
```

### Adding a new tool

Every tool, regardless of backend, follows the same three steps:

1. **`tools/<name>/`** — owns the binary.  Rust tools have `Cargo.toml` +
   `src/lib.rs`; C/C++ tools have a `download.sh` (placeholder for a future
   Emscripten compile step).  Build output lands in `pkg/` (gitignored).

2. **`Makefile` target `build-<name>`** — produces `pkg/` then copies it into
   `web/tools/<name>/`.  For Rust that means `wasm-pack build`; for C/C++ it
   means running `download.sh`.

3. **`web/<name>.ts`** — the tool module.  Exports an object with `id`, `name`,
   `description`, `init()`, and `render(container)`.  Register it in the
   `TOOLS` array in `web/main.ts`.  That's the only change outside the new
   files.

`init()` is called lazily on first sidebar click.  `render()` is called once
immediately after; the container persists (show/hide on tool switch).

## Build & run

```sh
make test-gc-calculator   # cargo test, no wasm build required
make run                  # wasm-pack build + tsc + dev server (port 8080)
```

The dev server (`serve`) must run from the **project root** so that both `web/` and `tools/*/pkg/` are reachable. The page is at `http://localhost:8080/web/`.

## Devcontainer

Image: `mcr.microsoft.com/devcontainers/rust:stable` + `wasm-pack` + Node 20 (via devcontainer feature). `postCreateCommand` runs `npm install`. Everything needed is in the container; nothing needs to be installed on the host.

## Conventions

- Tools serialize results to JSON from Rust (`serde_json`), JS parses with `JSON.parse()`. This keeps the Rust side language-agnostic and avoids the complexity of custom JsValue types.
- `Deserialize` is derived on result structs so unit tests can round-trip through JSON without a second struct.
- `pkg/` and `target/` inside each tool are gitignored via the root `.gitignore` globs (`tools/*/pkg/`, `tools/*/target/`).
- Escape all user-facing strings in the HTML via DOM text-node insertion (see `escapeHtml` in `main.ts`).
- The frontend is TypeScript. `wasm-pack` emits `.d.ts` declarations alongside the `.js` glue; `tsc` picks them up automatically via `bundler` module resolution. `web/main.js` is generated output (gitignored); the source is `web/main.ts`.
